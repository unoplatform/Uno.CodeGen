// ******************************************************************
// Copyright ï¿½ 2015-2018 nventive inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// ******************************************************************
using System.Collections.Generic;
using System.Linq;
using Microsoft.CodeAnalysis;
using Uno.Helpers;
using Uno.RoslynHelpers;
using Uno.SourceGeneration;

namespace Uno
{
	/// <summary>
	/// Responsible for the code generation of injectable types.
	/// </summary>
	/// <remarks>
	/// The trigger for this generator is <see cref="Uno.InjectAttribute"/>.
	/// </remarks>
	public class InjectableGenerator : SourceGenerator
	{
		private SourceGeneratorContext _context;
		private INamedTypeSymbol _injectAttributeSymbol;

		/// <inheritdoc />
		public override void Execute(SourceGeneratorContext context)
		{
			_context = context;
			_injectAttributeSymbol = context.Compilation.GetTypeByMetadataName("Uno.InjectAttribute");

			var injectables = EnumerateInjectables();

			foreach (var injectable in injectables)
			{
				GenerateInjectable(injectable);
			}
		}

		private IEnumerable<(INamedTypeSymbol type, IEnumerable<(ISymbol member, AttributeData attribute)> attributes)> EnumerateInjectables() =>
			from type in _context.Compilation.SourceModule.GlobalNamespace.GetNamespaceTypes()
			from member in Enumerable.Concat<ISymbol>(type.GetProperties(), type.GetFields())
			from attribute in member.GetAttributes()
			where attribute.AttributeClass == _injectAttributeSymbol		
			group (member, attribute) by type into g
			select (type: g.Key, attributes: g.AsEnumerable());

		private void GenerateInjectable((INamedTypeSymbol type, IEnumerable<(ISymbol member, AttributeData attribute)> attributes) injectable)
		{
			var typeNames = injectable.type.GetSymbolNames();
			var (typeName, genericArguments, typeNameWithGenerics, typeNameForXml, typeNameDefinition, resultFileName, genericConstraints) = typeNames;

			var builder = new IndentedStringBuilder();

			builder.AppendLineInvariant("// <auto-generated>");
			builder.AppendLineInvariant("// **************************************************************(********************************************************");
			builder.AppendLineInvariant("// This file has been generated by Uno.CodeGen (InjectableGenerator), available at https://github.com/unoplatform/Uno.CodeGen");
			builder.AppendLineInvariant("// ***********************************************************************************************************************");
			builder.AppendLineInvariant("// </auto-generated>");
			builder.AppendLineInvariant("#pragma warning disable");
			builder.AppendLine();
			builder.AppendLineInvariant("using System;");
			builder.AppendLine();

			using (builder.BlockInvariant($"namespace {injectable.type.ContainingNamespace}"))
			{
				using (builder.BlockInvariant($"partial class {injectable.type.Name} : global::Uno.IInjectable"))
				{
					using (builder.BlockInvariant($"void global::Uno.IInjectable.Inject(global::Uno.DependencyResolver resolver)"))
					{
						foreach (var attribute in injectable.attributes)
						{
							var memberName = attribute.member.Name;
							var memberType = GetMemberType(attribute.member);
							var memberTypeName = memberType.GetSymbolNames()?.GetSymbolFullNameWithGenerics() ?? memberType?.ToDisplayString();
							var name = attribute.attribute.ConstructorArguments.Select(x => x.Value?.ToString()).FirstOrDefault();
							var nameLiteral = name != null ? $"\"{name}\"" : "null";

							if (memberType.IsFunc(out var funcResultType)) // Resolve lazily
							{
								var funcResultTypeName = funcResultType?.GetSymbolNames()?.GetSymbolFullNameWithGenerics() ?? funcResultType?.ToDisplayString();
								builder.AppendLineInvariant($"{memberName} = () => ({funcResultTypeName})resolver(typeof({funcResultTypeName}), {nameLiteral});");
							}
							else
							{
								builder.AppendLineInvariant($"{memberName} = ({memberTypeName})resolver(typeof({memberTypeName}), {nameLiteral});");
							}
						}
					}
				}
			}

			_context.AddCompilationUnit(resultFileName, builder.ToString());
		}

		private static ITypeSymbol GetMemberType(ISymbol member)
		{
			switch (member)
			{
				case IPropertySymbol property:
					return property.Type;
				case IFieldSymbol field:
					return field.Type;
				default:
					return null;
			}
		}
	}
}
